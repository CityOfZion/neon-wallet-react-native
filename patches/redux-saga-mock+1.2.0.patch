diff --git a/node_modules/redux-saga-mock/dist/mockSaga.js b/node_modules/redux-saga-mock/dist/mockSaga.js
index 2c77ae2..b04d0ac 100644
--- a/node_modules/redux-saga-mock/dist/mockSaga.js
+++ b/node_modules/redux-saga-mock/dist/mockSaga.js
@@ -33,7 +33,7 @@ var _lodash2 = _interopRequireDefault(_lodash);
 
 function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
 
-var GeneratorFunction = _regenerator2.default.mark(function _callee() {
+var GeneratorFunction = /*#__PURE__*/_regenerator2.default.mark(function _callee() {
   return _regenerator2.default.wrap(function _callee$(_context) {
     while (1) {
       switch (_context.prev = _context.next) {
@@ -66,6 +66,9 @@ var isRACE = function isRACE(effect) {
 var isFORK = function isFORK(effect) {
   return _lodash2.default.isObject(effect) && effect['@@redux-saga/IO'] && effect.FORK;
 };
+var isALL = function isALL(effect) {
+  return _lodash2.default.isObject(effect) && effect['@@redux-saga/IO'] && effect.ALL;
+};
 
 var matchers = exports.matchers = {
   putAction: function putAction(action) {
@@ -100,6 +103,11 @@ var matchers = exports.matchers = {
       return isCALL(effect) && effect.CALL.fn === fn && _lodash2.default.isEqual(effect.CALL.args, args);
     };
   },
+  fork: function fork(fn) {
+    return function (effect) {
+      return isFORK(effect) && effect.FORK.fn === fn;
+    };
+  },
   forkGeneratorFn: function forkGeneratorFn() {
     return function (effect) {
       return isFORK(effect) && effect.FORK.fn instanceof GeneratorFunction;
@@ -140,6 +148,10 @@ function rreplace(matcher, effect, replEffCreator) {
     return _lodash2.default.map(effect, function (e) {
       return rreplace(matcher, e, replEffCreator);
     });
+  } else if (isALL(effect)) {
+    return (0, _assign2.default)({}, effect, {
+      ALL: rreplace(matcher, effect.ALL, replEffCreator)
+    });
   }
   return effect;
 }
@@ -155,7 +167,7 @@ function findAllIndexes(array, matcher) {
   return indexes;
 }
 
-var chainableMethods = ['onEffect', 'onTakeAction', 'onPutAction', 'onCall', 'onCallWithArgs', 'onCallWithExactArgs', 'onYieldEffect', 'onYieldTakeAction', 'onYieldPutAction', 'onYieldCall', 'onYieldCallWithArgs', 'onYieldCallWithExactArgs', 'stubCall', 'stubCallWithArgs', 'stubCallWithExactArgs', 'resetStubs', 'clearStoredEffects'];
+var chainableMethods = ['onEffect', 'onTakeAction', 'onPutAction', 'onCall', 'onCallWithArgs', 'onCallWithExactArgs', 'onYieldEffect', 'onYieldTakeAction', 'onYieldPutAction', 'onYieldCall', 'onYieldCallWithArgs', 'onYieldCallWithExactArgs', 'stubCall', 'stubCallWithArgs', 'stubCallWithExactArgs', 'stubFork', 'resetStubs', 'clearStoredEffects'];
 
 function isSaga(saga) {
   return Array.isArray(saga) || saga instanceof GeneratorFunction || !!saga.next;
@@ -213,105 +225,90 @@ function mockArray(sagas) {
 }
 
 function createGenerator(saga, effects, listenersPre, listenersPost, stubs) {
-  return _regenerator2.default.mark(function mockedGenerator() {
-    var _this = this;
-
-    var current,
-        _loop,
-        _args4 = arguments;
-
-    return _regenerator2.default.wrap(function mockedGenerator$(_context4) {
-      while (1) {
-        switch (_context4.prev = _context4.next) {
-          case 0:
-            if (saga instanceof GeneratorFunction) {
-              saga = saga.apply(undefined, _args4);
-            }
-            current = saga.next();
-            _loop = _regenerator2.default.mark(function _loop() {
-              var effect, stubbedEffect;
-              return _regenerator2.default.wrap(function _loop$(_context3) {
-                while (1) {
-                  switch (_context3.prev = _context3.next) {
-                    case 0:
-                      effect = current.value;
-                      // console.log('>> effect:', effect)
-
-                      effects.push(effect);
-                      listenersPre.forEach(function (l) {
-                        return recursive(l.match)(effect) && l.callback(effect);
-                      });
-                      stubbedEffect = stubs.reduce(function (seffect, stub) {
-                        return rreplace(stub.match, seffect, stub.stubCreator);
-                      }, effect);
-                      // if (stubbedEffect !== effect) console.log('>>>> stubbed effect:', stubbedEffect)
-
-                      _context3.prev = 4;
-                      return _context3.delegateYield(_regenerator2.default.mark(function _callee2() {
-                        var data;
-                        return _regenerator2.default.wrap(function _callee2$(_context2) {
-                          while (1) {
-                            switch (_context2.prev = _context2.next) {
-                              case 0:
-                                _context2.next = 2;
-                                return stubbedEffect;
-
-                              case 2:
-                                data = _context2.sent;
-
-                                listenersPost.forEach(function (l) {
-                                  return recursive(l.match)(effect) && l.callback({ effect: effect, data: data });
-                                });
-                                current = saga.next(data);
-
-                              case 5:
-                              case 'end':
-                                return _context2.stop();
-                            }
-                          }
-                        }, _callee2, _this);
-                      })(), 't0', 6);
-
-                    case 6:
-                      _context3.next = 11;
-                      break;
-
-                    case 8:
-                      _context3.prev = 8;
-                      _context3.t1 = _context3['catch'](4);
-
-                      current = saga.throw(_context3.t1);
-
-                    case 11:
-                    case 'end':
-                      return _context3.stop();
+  return (/*#__PURE__*/_regenerator2.default.mark(function mockedGenerator() {
+      var _this = this;
+
+      var current,
+          _loop,
+          _args3 = arguments;
+
+      return _regenerator2.default.wrap(function mockedGenerator$(_context3) {
+        while (1) {
+          switch (_context3.prev = _context3.next) {
+            case 0:
+              if (saga instanceof GeneratorFunction) {
+                saga = saga.apply(undefined, _args3);
+              }
+              current = saga.next();
+              _loop = /*#__PURE__*/_regenerator2.default.mark(function _loop() {
+                var effect, stubbedEffect, data;
+                return _regenerator2.default.wrap(function _loop$(_context2) {
+                  while (1) {
+                    switch (_context2.prev = _context2.next) {
+                      case 0:
+                        effect = current.value;
+                        // console.log('>> effect:', effect)
+
+                        effects.push(effect);
+                        listenersPre.forEach(function (l) {
+                          return recursive(l.match)(effect) && l.callback(effect);
+                        });
+                        stubbedEffect = stubs.reduce(function (seffect, stub) {
+                          return rreplace(stub.match, seffect, stub.stubCreator);
+                        }, effect);
+                        // if (stubbedEffect !== effect) console.log('>>>> stubbed effect:', stubbedEffect)
+
+                        _context2.prev = 4;
+                        _context2.next = 7;
+                        return stubbedEffect;
+
+                      case 7:
+                        data = _context2.sent;
+
+                        listenersPost.forEach(function (l) {
+                          return recursive(l.match)(effect) && l.callback({ effect: effect, data: data });
+                        });
+                        current = saga.next(data);
+                        _context2.next = 15;
+                        break;
+
+                      case 12:
+                        _context2.prev = 12;
+                        _context2.t0 = _context2['catch'](4);
+
+                        current = saga.throw(_context2.t0);
+
+                      case 15:
+                      case 'end':
+                        return _context2.stop();
+                    }
                   }
-                }
-              }, _loop, _this, [[4, 8]]);
-            });
+                }, _loop, _this, [[4, 12]]);
+              });
 
-          case 3:
-            if (current.done) {
-              _context4.next = 7;
-              break;
-            }
+            case 3:
+              if (current.done) {
+                _context3.next = 7;
+                break;
+              }
 
-            return _context4.delegateYield(_loop(), 't0', 5);
+              return _context3.delegateYield(_loop(), 't0', 5);
 
-          case 5:
-            _context4.next = 3;
-            break;
+            case 5:
+              _context3.next = 3;
+              break;
 
-          case 7:
-            return _context4.abrupt('return', current.value);
+            case 7:
+              return _context3.abrupt('return', current.value);
 
-          case 8:
-          case 'end':
-            return _context4.stop();
+            case 8:
+            case 'end':
+              return _context3.stop();
+          }
         }
-      }
-    }, mockedGenerator, this);
-  });
+      }, mockedGenerator, this);
+    })
+  );
 }
 
 function stubCallCreator(newTargetFn) {
@@ -321,6 +318,13 @@ function stubCallCreator(newTargetFn) {
   };
 }
 
+function stubForkCreator(newTargetFn) {
+  return function (effect) {
+    var cloned = _lodash2.default.cloneDeep(effect);
+    return _lodash2.default.set(cloned, 'FORK.fn', newTargetFn);
+  };
+}
+
 var addListener = function addListener(target, listeners, callback, matcher) {
   for (var _len2 = arguments.length, args = Array(_len2 > 4 ? _len2 - 4 : 0), _key2 = 4; _key2 < _len2; _key2++) {
     args[_key2 - 4] = arguments[_key2];
@@ -357,10 +361,10 @@ function mockGenerator(saga) {
 
   var createStub = function createStub(matcher, stubCreator) {
     if (!_lodash2.default.isFunction(stubCreator)) throw new Error('stub function required');
-    var s = { match: matcher, stubCreator: stubCreator };
-    // FIXME replacement works only with stubCall because its matcher is memoized and in the other cases
-    // the macher is created on every call
-    var pos = _lodash2.default.findIndex(stubs, matcher);
+    var s = { match: matcher, stubCreator: stubCreator
+      // FIXME replacement works only with stubCall because its matcher is memoized and in the other cases
+      // the macher is created on every call
+    };var pos = _lodash2.default.findIndex(stubs, matcher);
     if (pos !== -1) {
       stubs[pos] = s;
     } else {
@@ -442,6 +446,9 @@ function mockGenerator(saga) {
     stubCallWithExactArgs: function stubCallWithExactArgs(fn, args, stub) {
       return createStub(matchers.callWithExactArgs(fn, args), stubCallCreator(stub));
     },
+    stubFork: function stubFork(fn, stub) {
+      return createStub(matchers.fork(fn), stubForkCreator(stub));
+    },
     resetStubs: function resetStubs() {
       stubs.splice(stubs.length - 3, 3);return retval;
     }, // last 3 stubs are for forks, calls to generator and arrays
@@ -456,12 +463,10 @@ function mockGenerator(saga) {
 
 function createQueryMethods(getEffects) {
   if (Array.isArray(getEffects)) {
-    (function () {
-      var effects = getEffects;
-      getEffects = function getEffects() {
-        return effects;
-      };
-    })();
+    var effects = getEffects;
+    getEffects = function getEffects() {
+      return effects;
+    };
   }
   var findEffect = function findEffect(effect) {
     var fromPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
diff --git a/node_modules/redux-saga-mock/src/mockSaga.js b/node_modules/redux-saga-mock/src/mockSaga.js
index f3f1841..bb293b6 100644
--- a/node_modules/redux-saga-mock/src/mockSaga.js
+++ b/node_modules/redux-saga-mock/src/mockSaga.js
@@ -2,95 +2,93 @@ import _ from 'lodash'
 
 const GeneratorFunction = function*() {}.constructor
 
-export function mockSaga (saga) {
-  if (Array.isArray(saga)) return mockArray(saga)
-  if (saga instanceof GeneratorFunction || saga.next) return mockGenerator(saga)
-  throw new Error('saga must be a generator object, a generator function or an array')
+export function mockSaga(saga) {
+    if (Array.isArray(saga)) return mockArray(saga)
+    if (saga instanceof GeneratorFunction || saga.next) return mockGenerator(saga)
+    throw new Error('saga must be a generator object, a generator function or an array')
 }
 
-const isPUT = (effect) => _.isObject(effect) && effect['@@redux-saga/IO'] && effect.PUT
-const isTAKE = (effect) => _.isObject(effect) && effect['@@redux-saga/IO'] && effect.TAKE
-const isCALL = (effect) => _.isObject(effect) && effect['@@redux-saga/IO'] && effect.CALL
-const isRACE = (effect) => _.isObject(effect) && effect['@@redux-saga/IO'] && effect.RACE
-const isFORK = (effect) => _.isObject(effect) && effect['@@redux-saga/IO'] && effect.FORK
+const isPUT = effect => _.isObject(effect) && effect['@@redux-saga/IO'] && effect.PUT
+const isTAKE = effect => _.isObject(effect) && effect['@@redux-saga/IO'] && effect.TAKE
+const isCALL = effect => _.isObject(effect) && effect['@@redux-saga/IO'] && effect.CALL
+const isRACE = effect => _.isObject(effect) && effect['@@redux-saga/IO'] && effect.RACE
+const isFORK = effect => _.isObject(effect) && effect['@@redux-saga/IO'] && effect.FORK
+const isALL = effect => _.isObject(effect) && effect['@@redux-saga/IO'] && effect.ALL
 
 export const matchers = {
-  putAction: (action) => _.isString(action)
-    ? effect => isPUT(effect) && effect.PUT.action.type === action
-    : effect => isPUT(effect) && _.isEqual(effect.PUT.action, action),
-  takeAction: pattern =>
-    effect => isTAKE(effect) && effect.TAKE.pattern === pattern,
-  effect: effectToMatch =>
-    effect => _.isEqual(effect, effectToMatch),
-  call: _.memoize((fn) =>
-    effect => isCALL(effect) && effect.CALL.fn === fn),
-  callWithArgs: (fn, args) =>
-    effect => isCALL(effect) && effect.CALL.fn === fn && _.isMatch(effect.CALL.args, args),
-  callWithExactArgs: (fn, args) =>
-    effect => isCALL(effect) && effect.CALL.fn === fn && _.isEqual(effect.CALL.args, args),
-  forkGeneratorFn: () =>
-    effect => isFORK(effect) && effect.FORK.fn instanceof GeneratorFunction,
-  callGeneratorFn: () =>
-    effect => isCALL(effect) && effect.CALL.fn instanceof GeneratorFunction,
-  array: () =>
-    effect => _.isArray(effect)
+    putAction: action =>
+        _.isString(action)
+            ? effect => isPUT(effect) && effect.PUT.action.type === action
+            : effect => isPUT(effect) && _.isEqual(effect.PUT.action, action),
+    takeAction: pattern => effect => isTAKE(effect) && effect.TAKE.pattern === pattern,
+    effect: effectToMatch => effect => _.isEqual(effect, effectToMatch),
+    call: _.memoize(fn => effect => isCALL(effect) && effect.CALL.fn === fn),
+    callWithArgs: (fn, args) => effect => isCALL(effect) && effect.CALL.fn === fn && _.isMatch(effect.CALL.args, args),
+    callWithExactArgs: (fn, args) => effect => isCALL(effect) && effect.CALL.fn === fn && _.isEqual(effect.CALL.args, args),
+    forkGeneratorFn: () => effect => isFORK(effect) && effect.FORK.fn instanceof GeneratorFunction,
+    callGeneratorFn: () => effect => isCALL(effect) && effect.CALL.fn instanceof GeneratorFunction,
+    array: () => effect => _.isArray(effect)
 }
 
-function recursive (matcher) {
-  const rmatcher = (effect) => {
-    if (matcher(effect)) return true
-    else if (isRACE(effect)) {
-      return !!_.find(effect.RACE, rmatcher)
-    } else if (_.isArray(effect)) {
-      return !!effect.find(rmatcher)
+function recursive(matcher) {
+    const rmatcher = effect => {
+        if (matcher(effect)) return true
+        else if (isRACE(effect)) {
+            return !!_.find(effect.RACE, rmatcher)
+        } else if (_.isArray(effect)) {
+            return !!effect.find(rmatcher)
+        }
+        return false
     }
-    return false
-  }
-  return rmatcher
+    return rmatcher
 }
 
-function rreplace (matcher, effect, replEffCreator) {
-  if (matcher(effect)) return replEffCreator(effect)
-  else if (isRACE(effect)) {
-    return Object.assign({}, effect, {
-      RACE: _.mapValues(effect.RACE, (e) => rreplace(matcher, e, replEffCreator))
-    })
-  } else if (_.isArray(effect)) {
-    return _.map(effect, (e) => rreplace(matcher, e, replEffCreator))
-  }
-  return effect
+function rreplace(matcher, effect, replEffCreator) {
+    if (matcher(effect)) return replEffCreator(effect)
+    else if (isRACE(effect)) {
+        return Object.assign({}, effect, {
+            RACE: _.mapValues(effect.RACE, e => rreplace(matcher, e, replEffCreator))
+        })
+    } else if (_.isArray(effect)) {
+        return _.map(effect, e => rreplace(matcher, e, replEffCreator))
+    } else if (isALL(effect)) {
+        return Object.assign({}, effect, {
+            ALL: rreplace(matcher, effect.ALL, replEffCreator)
+        })
+    }
+    return effect
 }
 
-function findAllIndexes (array, matcher, fromPos = 0, last = (array.length - 1)) {
-  const indexes = []
-  for (let i = fromPos; i <= last; i++) {
-    if (matcher(array[i])) indexes.push(i)
-  }
-  return indexes
+function findAllIndexes(array, matcher, fromPos = 0, last = array.length - 1) {
+    const indexes = []
+    for (let i = fromPos; i <= last; i++) {
+        if (matcher(array[i])) indexes.push(i)
+    }
+    return indexes
 }
 
 const chainableMethods = [
-  'onEffect',
-  'onTakeAction',
-  'onPutAction',
-  'onCall',
-  'onCallWithArgs',
-  'onCallWithExactArgs',
-  'onYieldEffect',
-  'onYieldTakeAction',
-  'onYieldPutAction',
-  'onYieldCall',
-  'onYieldCallWithArgs',
-  'onYieldCallWithExactArgs',
-  'stubCall',
-  'stubCallWithArgs',
-  'stubCallWithExactArgs',
-  'resetStubs',
-  'clearStoredEffects'
+    'onEffect',
+    'onTakeAction',
+    'onPutAction',
+    'onCall',
+    'onCallWithArgs',
+    'onCallWithExactArgs',
+    'onYieldEffect',
+    'onYieldTakeAction',
+    'onYieldPutAction',
+    'onYieldCall',
+    'onYieldCallWithArgs',
+    'onYieldCallWithExactArgs',
+    'stubCall',
+    'stubCallWithArgs',
+    'stubCallWithExactArgs',
+    'resetStubs',
+    'clearStoredEffects'
 ]
 
-function isSaga (saga) {
-  return Array.isArray(saga) || saga instanceof GeneratorFunction || !!saga.next
+function isSaga(saga) {
+    return Array.isArray(saga) || saga instanceof GeneratorFunction || !!saga.next
 }
 
 /**
@@ -98,210 +96,218 @@ function isSaga (saga) {
  * @param sagas
  * @returns {array}
  */
-function mockArray (sagas) {
-  if (!Array.isArray(sagas)) throw new Error('sagas must be an array')
-  if (sagas.length === 0) return sagas
-
-  const mockedArray = sagas.map(s => mockSaga(s))
-  chainableMethods.forEach(name => {
-    Object.defineProperty(mockedArray, name, {
-      configurable: false,
-      enumerable: false,
-      writable: false,
-      value: (...args) => {
-        if (args.length > 1 && _.isFunction(args[args.length - 1])) {
-          mockedArray.forEach(s => s[name](...args))
-          return mockedArray
-        } else {
-          return Promise.race(mockedArray.map(s => s[name](...args)))
-        }
-      }
+function mockArray(sagas) {
+    if (!Array.isArray(sagas)) throw new Error('sagas must be an array')
+    if (sagas.length === 0) return sagas
+
+    const mockedArray = sagas.map(s => mockSaga(s))
+    chainableMethods.forEach(name => {
+        Object.defineProperty(mockedArray, name, {
+            configurable: false,
+            enumerable: false,
+            writable: false,
+            value: (...args) => {
+                if (args.length > 1 && _.isFunction(args[args.length - 1])) {
+                    mockedArray.forEach(s => s[name](...args))
+                    return mockedArray
+                } else {
+                    return Promise.race(mockedArray.map(s => s[name](...args)))
+                }
+            }
+        })
     })
-  })
-  const queryMethods = createQueryMethods(() => mockedArray.map(m => m.query().effects))
-  _.forEach(queryMethods, (fn, name) => {
-    Object.defineProperty(mockedArray, name, {
-      configurable: false,
-      enumerable: false,
-      writable: false,
-      value: fn
+    const queryMethods = createQueryMethods(() => mockedArray.map(m => m.query().effects))
+    _.forEach(queryMethods, (fn, name) => {
+        Object.defineProperty(mockedArray, name, {
+            configurable: false,
+            enumerable: false,
+            writable: false,
+            value: fn
+        })
     })
-  })
-  return mockedArray
+    return mockedArray
 }
 
-function createGenerator (saga, effects, listenersPre, listenersPost, stubs) {
-  return function * mockedGenerator (...args) {
-    if (saga instanceof GeneratorFunction) {
-      saga = saga(...args)
-    }
-    let current = saga.next()
-    while (!current.done) {
-      const effect = current.value
-      // console.log('>> effect:', effect)
-      effects.push(effect)
-      listenersPre.forEach((l) => recursive(l.match)(effect) && l.callback(effect))
-      const stubbedEffect = stubs.reduce((seffect, stub) => rreplace(stub.match, seffect, stub.stubCreator), effect)
-      // if (stubbedEffect !== effect) console.log('>>>> stubbed effect:', stubbedEffect)
-      try {
-        const data = yield stubbedEffect
-        listenersPost.forEach((l) => recursive(l.match)(effect) && l.callback({effect, data}))
-        current = saga.next(data)
-      } catch (error) {
-        current = saga.throw(error)
-      }
+function createGenerator(saga, effects, listenersPre, listenersPost, stubs) {
+    return function* mockedGenerator(...args) {
+        if (saga instanceof GeneratorFunction) {
+            saga = saga(...args)
+        }
+        let current = saga.next()
+        while (!current.done) {
+            const effect = current.value
+            // console.log('>> effect:', effect)
+            effects.push(effect)
+            listenersPre.forEach(l => recursive(l.match)(effect) && l.callback(effect))
+            const stubbedEffect = stubs.reduce((seffect, stub) => rreplace(stub.match, seffect, stub.stubCreator), effect)
+            // if (stubbedEffect !== effect) console.log('>>>> stubbed effect:', stubbedEffect)
+            try {
+                const data = yield stubbedEffect
+                listenersPost.forEach(l => recursive(l.match)(effect) && l.callback({ effect, data }))
+                current = saga.next(data)
+            } catch (error) {
+                current = saga.throw(error)
+            }
+        }
+        return current.value
     }
-    return current.value
-  }
 }
 
-function stubCallCreator (newTargetFn) {
-  return effect => {
-    let cloned = _.cloneDeep(effect)
-    return _.set(cloned, 'CALL.fn', newTargetFn)
-  }
+function stubCallCreator(newTargetFn) {
+    return effect => {
+        let cloned = _.cloneDeep(effect)
+        return _.set(cloned, 'CALL.fn', newTargetFn)
+    }
 }
 
 const addListener = (target, listeners, callback, matcher, ...args) => {
-  let retval
-  if (callback) {
-    retval = target
-  } else {
-    retval = new Promise((resolve, reject) => {
-      callback = _.once((effect) => resolve(effect))
-    })
-  }
-  listeners.push({ match: matcher(...args), callback })
-  return retval
+    let retval
+    if (callback) {
+        retval = target
+    } else {
+        retval = new Promise((resolve, reject) => {
+            callback = _.once(effect => resolve(effect))
+        })
+    }
+    listeners.push({ match: matcher(...args), callback })
+    return retval
 }
 
-function mockGenerator (saga) {
-  if (!saga.next && !(saga instanceof GeneratorFunction)) throw new Error('invalid generator')
+function mockGenerator(saga) {
+    if (!saga.next && !(saga instanceof GeneratorFunction)) throw new Error('invalid generator')
 
-  const effects = []
-  const stubs = []
-  // listeners
-  const lstPre = []
-  const lstPost = []
+    const effects = []
+    const stubs = []
+    // listeners
+    const lstPre = []
+    const lstPost = []
 
-  const mockedGeneratorFn = createGenerator(saga, effects, lstPre, lstPost, stubs)
+    const mockedGeneratorFn = createGenerator(saga, effects, lstPre, lstPost, stubs)
 
-  const mockedGeneratorObj = mockedGeneratorFn()
+    const mockedGeneratorObj = mockedGeneratorFn()
 
-  const retval = saga instanceof GeneratorFunction
-    ? mockedGeneratorFn
-    : mockedGeneratorObj
+    const retval = saga instanceof GeneratorFunction ? mockedGeneratorFn : mockedGeneratorObj
 
-  const createStub = (matcher, stubCreator) => {
-    if (!_.isFunction(stubCreator)) throw new Error('stub function required')
-    const s = { match: matcher, stubCreator }
-    // FIXME replacement works only with stubCall because its matcher is memoized and in the other cases
-    // the macher is created on every call
-    const pos = _.findIndex(stubs, matcher)
-    if (pos !== -1) {
-      stubs[pos] = s
-    } else {
-      stubs.unshift(s)
+    const createStub = (matcher, stubCreator) => {
+        if (!_.isFunction(stubCreator)) throw new Error('stub function required')
+        const s = { match: matcher, stubCreator }
+        // FIXME replacement works only with stubCall because its matcher is memoized and in the other cases
+        // the macher is created on every call
+        const pos = _.findIndex(stubs, matcher)
+        if (pos !== -1) {
+            stubs[pos] = s
+        } else {
+            stubs.unshift(s)
+        }
+        return retval
     }
-    return retval
-  }
-
-  const stubFork = (effect) => {
-    const cloned = _.cloneDeep(effect)
-    const mockedSubGenFn = createGenerator(effect.FORK.fn, effects, lstPre, lstPost, stubs)
-    return _.set(cloned, 'FORK.fn', mockedSubGenFn)
-  }
-
-  const stubCallGeneratorFn = (effect) => {
-    const cloned = _.cloneDeep(effect)
-    const mockedSubGenFn = createGenerator(effect.CALL.fn, effects, lstPre, lstPost, stubs)
-    return _.set(cloned, 'CALL.fn', mockedSubGenFn)
-  }
-
-  const stubArray = (effect) => {
-    return effect.map(e => {
-      if (Array.isArray(e)) return stubArray(e)
-      if (e.next) return createGenerator(e, effects, lstPre, lstPost, stubs)()
-      if (e instanceof GeneratorFunction) return createGenerator(e, effects, lstPre, lstPost, stubs)
-      return e
-    })
-  }
-
-  createStub(matchers.forkGeneratorFn(), stubFork)
-  createStub(matchers.callGeneratorFn(), stubCallGeneratorFn)
-  createStub(matchers.array(), stubArray)
-
-  const chainableMethods = {
-    onEffect: (effect, callback) => addListener(retval, lstPre, callback, matchers.effect, effect),
-    onTakeAction: (pattern, callback) => addListener(retval, lstPre, callback, matchers.takeAction, pattern),
-    onPutAction: (action, callback) => addListener(retval, lstPre, callback, matchers.putAction, action),
-    onCall: (fn, callback) => addListener(retval, lstPre, callback, matchers.call, fn),
-    onCallWithArgs: (fn, args, callback) => addListener(retval, lstPre, callback, matchers.callWithArgs, fn, args),
-    onCallWithExactArgs: (fn, args, callback) => addListener(retval, lstPre, callback, matchers.callWithExactArgs, fn, args),
-
-    onYieldEffect: (effect, callback) => addListener(retval, lstPost, callback, matchers.effect, effect),
-    onYieldTakeAction: (pattern, callback) => addListener(retval, lstPost, callback, matchers.takeAction, pattern),
-    onYieldPutAction: (action, callback) => addListener(retval, lstPost, callback, matchers.putAction, action),
-    onYieldCall: (fn, callback) => addListener(retval, lstPost, callback, matchers.call, fn),
-    onYieldCallWithArgs: (fn, args, callback) => addListener(retval, lstPost, callback, matchers.callWithArgs, fn, args),
-    onYieldCallWithExactArgs: (fn, args, callback) => addListener(retval, lstPost, callback, matchers.callWithExactArgs, fn, args),
-
-    stubCall: (fn, stub) => createStub(matchers.call(fn), stubCallCreator(stub)),
-    stubCallWithArgs: (fn, args, stub) => createStub(matchers.callWithArgs(fn, args), stubCallCreator(stub)),
-    stubCallWithExactArgs: (fn, args, stub) => createStub(matchers.callWithExactArgs(fn, args), stubCallCreator(stub)),
-    resetStubs: () => { stubs.splice(stubs.length - 3, 3); return retval },  // last 3 stubs are for forks, calls to generator and arrays
-    clearStoredEffects: () => { effects.length = 0; return retval }
-  }
-
-  const queryMethods = createQueryMethods(effects)
-  return Object.assign(retval, queryMethods, chainableMethods)
+
+    const stubFork = effect => {
+        const cloned = _.cloneDeep(effect)
+        const mockedSubGenFn = createGenerator(effect.FORK.fn, effects, lstPre, lstPost, stubs)
+        return _.set(cloned, 'FORK.fn', mockedSubGenFn)
+    }
+
+    const stubCallGeneratorFn = effect => {
+        const cloned = _.cloneDeep(effect)
+        const mockedSubGenFn = createGenerator(effect.CALL.fn, effects, lstPre, lstPost, stubs)
+        return _.set(cloned, 'CALL.fn', mockedSubGenFn)
+    }
+
+    const stubArray = effect => {
+        return effect.map(e => {
+            if (Array.isArray(e)) return stubArray(e)
+            if (e.next) return createGenerator(e, effects, lstPre, lstPost, stubs)()
+            if (e instanceof GeneratorFunction) return createGenerator(e, effects, lstPre, lstPost, stubs)
+            return e
+        })
+    }
+
+    createStub(matchers.forkGeneratorFn(), stubFork)
+    createStub(matchers.callGeneratorFn(), stubCallGeneratorFn)
+    createStub(matchers.array(), stubArray)
+
+    const chainableMethods = {
+        onEffect: (effect, callback) => addListener(retval, lstPre, callback, matchers.effect, effect),
+        onTakeAction: (pattern, callback) => addListener(retval, lstPre, callback, matchers.takeAction, pattern),
+        onPutAction: (action, callback) => addListener(retval, lstPre, callback, matchers.putAction, action),
+        onCall: (fn, callback) => addListener(retval, lstPre, callback, matchers.call, fn),
+        onCallWithArgs: (fn, args, callback) => addListener(retval, lstPre, callback, matchers.callWithArgs, fn, args),
+        onCallWithExactArgs: (fn, args, callback) => addListener(retval, lstPre, callback, matchers.callWithExactArgs, fn, args),
+
+        onYieldEffect: (effect, callback) => addListener(retval, lstPost, callback, matchers.effect, effect),
+        onYieldTakeAction: (pattern, callback) => addListener(retval, lstPost, callback, matchers.takeAction, pattern),
+        onYieldPutAction: (action, callback) => addListener(retval, lstPost, callback, matchers.putAction, action),
+        onYieldCall: (fn, callback) => addListener(retval, lstPost, callback, matchers.call, fn),
+        onYieldCallWithArgs: (fn, args, callback) => addListener(retval, lstPost, callback, matchers.callWithArgs, fn, args),
+        onYieldCallWithExactArgs: (fn, args, callback) => addListener(retval, lstPost, callback, matchers.callWithExactArgs, fn, args),
+
+        stubCall: (fn, stub) => createStub(matchers.call(fn), stubCallCreator(stub)),
+        stubCallWithArgs: (fn, args, stub) => createStub(matchers.callWithArgs(fn, args), stubCallCreator(stub)),
+        stubCallWithExactArgs: (fn, args, stub) => createStub(matchers.callWithExactArgs(fn, args), stubCallCreator(stub)),
+        resetStubs: () => {
+            stubs.splice(stubs.length - 3, 3)
+            return retval
+        }, // last 3 stubs are for forks, calls to generator and arrays
+        clearStoredEffects: () => {
+            effects.length = 0
+            return retval
+        }
+    }
+
+    const queryMethods = createQueryMethods(effects)
+    return Object.assign(retval, queryMethods, chainableMethods)
 }
 
-function createQueryMethods (getEffects) {
-  if (Array.isArray(getEffects)) {
-    const effects = getEffects
-    getEffects = () => effects
-  }
-  const findEffect = (effect, fromPos = 0, last) => findAllIndexes(getEffects(), recursive(matchers.effect(effect)), fromPos, last)
-  const findPuttedAction = (action, fromPos = 0, last) => findAllIndexes(getEffects(), recursive(matchers.putAction(action)), fromPos, last)
-  const findTakenAction = (pattern, fromPos = 0, last) => findAllIndexes(getEffects(), recursive(matchers.takeAction(pattern)), fromPos, last)
-  const findCall = (fn, fromPos = 0, last) => findAllIndexes(getEffects(), recursive(matchers.call(fn)), fromPos, last)
-  const findCallWithArgs = (fn, args, fromPos = 0, last) => findAllIndexes(getEffects(), recursive(matchers.callWithArgs(fn, args)), fromPos, last)
-  const findCallWithExactArgs = (fn, args, fromPos = 0, last) => findAllIndexes(getEffects(), recursive(matchers.callWithExactArgs(fn, args)), fromPos, last)
-
-  const createOrderedQueries = (from, last) => ({
-    effect: effect => createResult(findEffect(effect, from, last)),
-    putAction: action => createResult(findPuttedAction(action, from, last)),
-    takeAction: pattern => createResult(findTakenAction(pattern, from, last)),
-    call: fn => createResult(findCall(fn, from, last)),
-    callWithArgs: (fn, ...args) => createResult(findCallWithArgs(fn, args, from, last)),
-    callWithExactArgs: (fn, ...args) => createResult(findCallWithExactArgs(fn, args, from, last))
-  })
-
-  function createResult (indexes) {
-    const isPresent = indexes.length > 0
-    const filteredEffects = indexes.map(i => getEffects()[i])
-    const count = indexes.length
-    const next = isPresent ? indexes[0] + 1 : 0
-    const prev = isPresent ? indexes[count - 1] - 1 : 0
-    return Object.assign(
-      {
-        indexes,
-        effects: filteredEffects,
-        isPresent,
-        notPresent: !isPresent,
-        count,
-        number: num => createResult(num >= 0 && num <= count ? [indexes[num]] : []),
-        first: () => createResult(isPresent ? [indexes[0]] : []),
-        last: () => createResult(isPresent ? [indexes[count - 1]] : []),
-        followedBy: createOrderedQueries(next),
-        precededBy: createOrderedQueries(0, prev)
-      },
-      createOrderedQueries()
-    )
-  }
-
-  return {
-    query: () => createResult(Array.from(getEffects().keys()))
-  }
+function createQueryMethods(getEffects) {
+    if (Array.isArray(getEffects)) {
+        const effects = getEffects
+        getEffects = () => effects
+    }
+    const findEffect = (effect, fromPos = 0, last) => findAllIndexes(getEffects(), recursive(matchers.effect(effect)), fromPos, last)
+    const findPuttedAction = (action, fromPos = 0, last) =>
+        findAllIndexes(getEffects(), recursive(matchers.putAction(action)), fromPos, last)
+    const findTakenAction = (pattern, fromPos = 0, last) =>
+        findAllIndexes(getEffects(), recursive(matchers.takeAction(pattern)), fromPos, last)
+    const findCall = (fn, fromPos = 0, last) => findAllIndexes(getEffects(), recursive(matchers.call(fn)), fromPos, last)
+    const findCallWithArgs = (fn, args, fromPos = 0, last) =>
+        findAllIndexes(getEffects(), recursive(matchers.callWithArgs(fn, args)), fromPos, last)
+    const findCallWithExactArgs = (fn, args, fromPos = 0, last) =>
+        findAllIndexes(getEffects(), recursive(matchers.callWithExactArgs(fn, args)), fromPos, last)
+
+    const createOrderedQueries = (from, last) => ({
+        effect: effect => createResult(findEffect(effect, from, last)),
+        putAction: action => createResult(findPuttedAction(action, from, last)),
+        takeAction: pattern => createResult(findTakenAction(pattern, from, last)),
+        call: fn => createResult(findCall(fn, from, last)),
+        callWithArgs: (fn, ...args) => createResult(findCallWithArgs(fn, args, from, last)),
+        callWithExactArgs: (fn, ...args) => createResult(findCallWithExactArgs(fn, args, from, last))
+    })
+
+    function createResult(indexes) {
+        const isPresent = indexes.length > 0
+        const filteredEffects = indexes.map(i => getEffects()[i])
+        const count = indexes.length
+        const next = isPresent ? indexes[0] + 1 : 0
+        const prev = isPresent ? indexes[count - 1] - 1 : 0
+        return Object.assign(
+            {
+                indexes,
+                effects: filteredEffects,
+                isPresent,
+                notPresent: !isPresent,
+                count,
+                number: num => createResult(num >= 0 && num <= count ? [indexes[num]] : []),
+                first: () => createResult(isPresent ? [indexes[0]] : []),
+                last: () => createResult(isPresent ? [indexes[count - 1]] : []),
+                followedBy: createOrderedQueries(next),
+                precededBy: createOrderedQueries(0, prev)
+            },
+            createOrderedQueries()
+        )
+    }
+
+    return {
+        query: () => createResult(Array.from(getEffects().keys()))
+    }
 }
